#!/bin/bash
GREEN="\033[0;32m"
RED="\033[0;31m"
YELLOW="\033[1;33m"
TEXTRESET="\033[0m"

# ========= VALIDATION HELPERS =========
validate_cidr() { [[ "$1" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}/([0-9]|[1-2][0-9]|3[0-2])$ ]]; }
validate_ip()   { [[ "$1" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; }
validate_fqdn() { [[ "$1" =~ ^[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)+$ ]]; }

is_host_ip() {
  local cidr="$1"
  local ip_part="${cidr%/*}"
  local mask="${cidr#*/}"

  IFS='.' read -r o1 o2 o3 o4 <<< "$ip_part"
  ip_dec=$(( (o1 << 24) + (o2 << 16) + (o3 << 8) + o4 ))

  netmask=$(( 0xFFFFFFFF << (32 - mask) & 0xFFFFFFFF ))
  network=$(( ip_dec & netmask ))
  broadcast=$(( network | ~netmask & 0xFFFFFFFF ))

  [[ "$ip_dec" -eq "$network" || "$ip_dec" -eq "$broadcast" ]] && return 1 || return 0
}

check_hostname_in_domain() {
  local fqdn="$1"
  local hostname="${fqdn%%.*}"
  local domain="${fqdn#*.}"
  [[ ! "$domain" =~ (^|\.)"$hostname"(\.|$) ]]
}

# ========= SYSTEM CHECKS =========
check_root_and_os() {
  if [[ "$EUID" -ne 0 ]]; then
    dialog --aspect 9 --title "Permission Denied" --msgbox "This script must be run as root." 7 50
    clear; exit 1
  fi

  if [[ -f /etc/redhat-release ]]; then
    MAJOROS=$(grep -oP '\d+' /etc/redhat-release | head -1)
  else
    dialog --title "OS Check Failed" --msgbox "/etc/redhat-release not found. Cannot detect OS." 7 50
    exit 1
  fi

  if [[ "$MAJOROS" -lt 9 ]]; then
    dialog --title "Unsupported OS" --msgbox "This installer requires Rocky Linux 9.x or later." 7 50
    exit 1
  fi
}
# ========= SELINUX CHECK =========
check_and_enable_selinux() {
  local current_status=$(getenforce)

  if [[ "$current_status" == "Enforcing" ]]; then
    dialog --title "SELinux Status" --infobox "SELinux is already enabled and enforcing." 6 50
    sleep 4
  else
    dialog --title "SELinux Disabled" --msgbox "SELinux is not enabled. Enabling SELinux now..." 6 50
    sed -i 's/SELINUX=disabled/SELINUX=enforcing/' /etc/selinux/config
    setenforce 1

    if [[ "$(getenforce)" == "Enforcing" ]]; then
      dialog --title "SELinux Enabled" --msgbox "SELinux has been successfully enabled and is now enforcing." 6 50
    else
      dialog --title "SELinux Error" --msgbox "Failed to enable SELinux. Please check the configuration manually." 6 50
      exit 1
    fi
  fi
}
# ========= NETWORK INTERFACE CHECK =========
network_interface_count() {
  # Get the list of network interfaces excluding loopback, bridges, and virtual interfaces
  interfaces=$(ip link show | awk -F: '$0 !~ "lo|vir|br|^[^0-9]"{gsub(/^[ \t]+/, "", $2); print $2; getline}')
  interface_count=$(echo "$interfaces" | wc -l)

  if [ "$interface_count" -ge 2 ]; then
    interface_list=$(echo "$interfaces" | sed 's/^/ - /')

    # Build the dialog message using printf to preserve line breaks
    dialog --title "Hardware Interface Check" --infobox "$(printf "PASS: At Least 2 Interfaces found\n\n%s\n\n" "$interface_list")" 15 60
    sleep 3
  else
    dialog --title "Hardware Interface Check Failed" \
           --msgbox "Less than two usable network interfaces were found.\n\nPlease make sure this system has at least two active interfaces. Tha
t are detected by nmcli." 10 60
    exit 1
  fi
}
# ========= NETWORK DETECTION =========
detect_active_interface() {
  dialog --title "Interface Check" --infobox "Checking active network interface..." 5 50
  sleep 3

  # Attempt 1: Use nmcli to find connected Ethernet
  INTERFACE=$(nmcli -t -f DEVICE,TYPE,STATE device | grep "ethernet:connected" | cut -d: -f1 | head -n1)

  # Attempt 2: Fallback to any interface with an IP if nmcli fails
  if [[ -z "$INTERFACE" ]]; then
    INTERFACE=$(ip -o -4 addr show up | grep -v ' lo ' | awk '{print $2}' | head -n1)
  fi

  # Get the matching connection profile name
  if [[ -n "$INTERFACE" ]]; then
    CONNECTION=$(nmcli -t -f NAME,DEVICE connection show | grep ":$INTERFACE" | cut -d: -f1)
  fi

  # Log to /tmp in case of failure
  echo "DEBUG: INTERFACE=$INTERFACE" >> /tmp/rfwb_debug.log
  echo "DEBUG: CONNECTION=$CONNECTION" >> /tmp/rfwb_debug.log

  if [[ -z "$INTERFACE" || -z "$CONNECTION" ]]; then
    dialog --clear  --no-ok --title "Interface Error" --aspect 9 --msgbox "No active network interface with IP found. Check /tmp/rfwb_debug.log for details." 5 70
    exit 1
  fi

  export INTERFACE CONNECTION
}
# ========= STATIC IP CONFIG =========
prompt_static_ip_if_dhcp() {
  IP_METHOD=$(nmcli -g ipv4.method connection show "$CONNECTION" | tr -d '
' | xargs)

  if [[ "$IP_METHOD" == "manual" ]]; then
  dialog --clear --title "Static IP Detected" --aspect 9 --msgbox "Interface '$INTERFACE' is already using a static IP.
No changes needed." 6 70
  return
elif [[ "$IP_METHOD" == "auto" ]]; then
    while true; do
      while true; do
        IPADDR=$(dialog --title "Static IP" --inputbox "Enter static IP in CIDR format (e.g., 192.168.1.100/24):" 8 60 3>&1 1>&2 2>&3)
        validate_cidr "$IPADDR" && break || dialog --msgbox "Invalid CIDR format. Try again." 6 40
      done

      while true; do
        GW=$(dialog --title "Gateway" --inputbox "Enter default gateway:" 8 60 3>&1 1>&2 2>&3)
        validate_ip "$GW" && break || dialog --msgbox "Invalid IP address. Try again." 6 40
      done

      while true; do
        HOSTNAME=$(dialog --title "FQDN" --inputbox "Enter FQDN (e.g., host.domain.com):" 8 60 3>&1 1>&2 2>&3)
        if validate_fqdn "$HOSTNAME" && check_hostname_in_domain "$HOSTNAME"; then break
        else dialog --msgbox "Invalid FQDN or hostname repeated in domain. Try again." 7 60
        fi
      done

      while true; do
        DNSSERVER=$(dialog --title "DNS Server" --inputbox "Enter DNS server IP:" 8 60 3>&1 1>&2 2>&3)
        validate_ip "$DNSSERVER" && break || dialog --msgbox "Invalid IP address. Try again." 6 40
      done

      while true; do
        DNSSEARCH=$(dialog --title "DNS Search" --inputbox "Enter domain search suffix (e.g., localdomain):" 8 60 3>&1 1>&2 2>&3)
        [[ -n "$DNSSEARCH" ]] && break || dialog --msgbox "Search domain cannot be blank." 6 40
      done

      dialog --title "Confirm Settings" --yesno "Apply these settings?\n\nInterface: $INTERFACE\nIP: $IPADDR\nGW: $GW\nFQDN: $HOSTNAME\nDNS: $DNSSERVER\nSearch: $DNSS
EARCH" 12 60

      if [[ $? -eq 0 ]]; then
        nmcli con mod "$CONNECTION" ipv4.address "$IPADDR"
        nmcli con mod "$CONNECTION" ipv4.gateway "$GW"
        nmcli con mod "$CONNECTION" ipv4.method manual
        nmcli con mod "$CONNECTION" ipv4.dns "$DNSSERVER"
        nmcli con mod "$CONNECTION" ipv4.dns-search "$DNSSEARCH"
        hostnamectl set-hostname "$HOSTNAME"
        echo "/root/RFWB/rfwb_install.sh" >> /root/.bash_profile

        dialog --clear --no-shadow --no-ok --title "Reboot Required" --aspect 9 --msgbox "Static IP and hostname set. System will reboot. Reconnect at: ${IPADDR%%/*}"
 5 70
        reboot
      fi
    done
  fi
}
# ========= UI SCREENS =========
show_welcome_screen() {
  clear
  echo -e "${GREEN}
                               .*((((((((((((((((*
                         .(((((((((((((((((((((((((((/
                      ,((((((((((((((((((((((((((((((((((.
                    (((((((((((((((((((((((((((((((((((((((/
                  (((((((((((((((((((((((((((((((((((((((((((/
                .(((((((((((((((((((((((((((((((((((((((((((((
               ,((((((((((((((((((((((((((((((((((((((((((((((((.
               ((((((((((((((((((((((((((((((/   ,(((((((((((((((
              /((((((((((((((((((((((((((((.        /((((((((((((*
              ((((((((((((((((((((((((((/              ((((((((((
              ((((((((((((((((((((((((                   *((((((/
              /((((((((((((((((((((*                        (((((*
               ((((((((((((((((((             (((*            ,((
               .((((((((((((((.            /(((((((
                 ((((((((((/             (((((((((((((/
                  *((((((.            /((((((((((((((((((.
                    *(*)            ,(((((((((((((((((((((((,
                                 (((((((((((((((((((((((/
                              /((((((((((((((((((((((.
                                ,((((((((((((((,
${RESET}"
  echo -e "${GREEN}Rocky Linux${RESET} ${RED}Firewall${RESET} ${YELLOW}Builder${RESET}"

  sleep 2
  dialog --title "Rocky Firewall Builder Installation Script" --msgbox "\nWelcome to the Rocky Firewall Builder!\n\nThis script will configure networking and install 
required components.\n\n" 12 60
}



# ========= INTERNET CONNECTIVITY CHECK =========
check_internet_connectivity() {
  dialog --title "Network Test" --infobox "Checking internet connectivity..." 5 50
  sleep 2

  local dns_test="FAILED"
  local ip_test="FAILED"

  if ping -c 1 -W 2 google.com &>/dev/null; then
    dns_test="SUCCESS"
  fi

  if ping -c 1 -W 2 8.8.8.8 &>/dev/null; then
    ip_test="SUCCESS"
  fi

  dialog --title "Connectivity Test Results" --infobox "DNS Resolution: $dns_test
Direct IP (8.8.8.8): $ip_test " 7 50
  sleep 4

  if [[ "$dns_test" == "FAILED" || "$ip_test" == "FAILED" ]]; then
    dialog --title "Network Warning" --yesno "Internet connectivity issues detected. Do you want to continue?" 7 50
    if [[ $? -ne 0 ]]; then
      exit 1
    fi
  fi
}

# ========= HOSTNAME VALIDATION =========
validate_and_set_hostname() {
  local current_hostname=$(hostname)
  if [[ "$current_hostname" == "localhost.localdomain" ]]; then
    while true; do
      NEW_HOSTNAME=$(dialog --title "Hostname Configuration" --inputbox \
        "Current hostname is '$current_hostname'. Please enter a new FQDN (e.g., server.example.com):" \
        8 60 3>&1 1>&2 2>&3)
      
      if validate_fqdn "$NEW_HOSTNAME" && check_hostname_in_domain "$NEW_HOSTNAME"; then
        hostnamectl set-hostname "$NEW_HOSTNAME"
        dialog --title "Hostname Set" --msgbox "Hostname updated to: $NEW_HOSTNAME" 6 50
        break
      else
        dialog --title "Invalid Hostname" --msgbox "The entered hostname is invalid. Please try again." 6 50
      fi
    done
  else
    # Auto-dismiss message after 4 seconds, no OK button
    dialog --title "Hostname Check" --infobox \
      "The current hostname is '$current_hostname'." \
      6 60
    sleep 4
  fi
}


update_and_install_packages() {
  local current_hostname=$(hostname)
  if [[ "$current_hostname" == "localhost.localdomain" ]]; then
    while true; do
      NEW_HOSTNAME=$(dialog --title "Hostname Configuration" --inputbox "Current hostname is '$current_hostname'. Please enter a new FQDN (e.g., server.example.com):"
 8 60 3>&1 1>&2 2>&3)
      if validate_fqdn "$NEW_HOSTNAME" && check_hostname_in_domain "$NEW_HOSTNAME"; then
        hostnamectl set-hostname "$NEW_HOSTNAME"
        dialog --title "Hostname Set" --msgbox "Hostname updated to: $NEW_HOSTNAME" 6 50
        break
      else
        dialog --title "Invalid Hostname" --msgbox "The entered hostname is invalid. Please try again." 6 50
      fi
    done
  else
    dialog --title "Hostname Check" --msgbox "The current hostname is '$current_hostname'. No changes needed." 6 50
  fi
}

# ========= SYSTEM UPDATE & PACKAGE INSTALL =========
update_and_install_packages() {
  dialog --title "System Update" --infobox "Checking for updates..." 5 50
  sleep 2

  dnf check-update -y &>/dev/null
  
  TEMP_FILE=$(mktemp)
  dnf check-update | awk '{print $1}' | grep -vE '^$|Obsoleting|Last' | awk -F'.' '{print $1}' | sort -u > "$TEMP_FILE"

  PACKAGE_LIST=($(cat "$TEMP_FILE"))
  TOTAL_PACKAGES=${#PACKAGE_LIST[@]}

  if [[ "$TOTAL_PACKAGES" -eq 0 ]]; then
    dialog --title "System Update" --msgbox "No updates available!" 6 50
    rm -f "$TEMP_FILE"
  else
    PIPE=$(mktemp -u)
    mkfifo "$PIPE"
    dialog --title "System Update" --gauge "Installing updates..." 10 70 0 < "$PIPE" &
    exec 3>"$PIPE"
    COUNT=0
    for PACKAGE in "${PACKAGE_LIST[@]}"; do
      ((COUNT++))
      PERCENT=$(( (COUNT * 100) / TOTAL_PACKAGES ))
      echo "$PERCENT" > "$PIPE"
      echo "XXX" > "$PIPE"
      echo "Updating: $PACKAGE" > "$PIPE"
      echo "XXX" > "$PIPE"
      dnf -y install "$PACKAGE" >/dev/null 2>&1
    done
    exec 3>&-
    rm -f "$PIPE" "$TEMP_FILE"
  fi

  dialog --title "Package Installation" --infobox "Installing required packages..." 5 50
  sleep 2
  PACKAGE_LIST=("ntsysv" "iptraf" "fail2ban" "tuned" "net-tools" "dmidecode" "ipcalc" "bind-utils" "expect" "jq" "bc" "iproute-tc" "iw" "hostapd" "iotop" "zip" "yum-u
tils" "nano" "curl" "wget" "policycoreutils-python-utils" "dnf-automatic")
  TOTAL_PACKAGES=${#PACKAGE_LIST[@]}

  PIPE=$(mktemp -u)
  mkfifo "$PIPE"
  dialog --title "Ancillary Package Install" --gauge "Preparing to install packages..." 10 70 0 < "$PIPE" &
  exec 3>"$PIPE"
  COUNT=0
  for PACKAGE in "${PACKAGE_LIST[@]}"; do
    ((COUNT++))
    PERCENT=$(( (COUNT * 100) / TOTAL_PACKAGES ))
    echo "$PERCENT" > "$PIPE"
    echo "XXX" > "$PIPE"
    echo "Installing: $PACKAGE" > "$PIPE"
    echo "XXX" > "$PIPE"
    dnf -y install "$PACKAGE" >/dev/null 2>&1
  done
  exec 3>&-
  rm -f "$PIPE"
  dialog --title "Installation Complete" --msgbox "All packages installed successfully!" 6 50
}
# ========= Check hardware platform for VM state and install Guest Agent if needed =========
vm_detection() {
  PIPE=$(mktemp -u)
  mkfifo "$PIPE"

  # Start dialog gauge in background
  dialog --title "VM Guest Installation" --gauge "Initializing..." 10 60 0 < "$PIPE" &
  GAUGE_PID=$!

  DEBUG_LOG="/tmp/vm_detection_debug.txt"
  echo "=== VM Detection Debug Log ===" > "$DEBUG_LOG"

  (
    echo "10"
    echo "XXX"
    echo "Detecting virtualization platform..."
    echo "XXX"
    sleep 1

    # Get platform info
    PLATFORM_INFO=$(dmidecode)
    echo "$PLATFORM_INFO" >> "$DEBUG_LOG"

    # Detect platforms
    HWKVM=$(echo "$PLATFORM_INFO" | grep -i -e manufacturer -e product -e vendor | grep -w KVM)
    HWVMWARE=$(echo "$PLATFORM_INFO" | grep -i -e manufacturer -e product -e vendor | grep -w "VMware, Inc.")
    HWSEABIOS=$(echo "$PLATFORM_INFO" | grep -A5 "BIOS Information" | grep -i "Vendor" | grep -i "SeaBIOS")

    echo "Detected KVM: $HWKVM" >> "$DEBUG_LOG"
    echo "Detected VMware: $HWVMWARE" >> "$DEBUG_LOG"
    echo "Detected SeaBIOS: $HWSEABIOS" >> "$DEBUG_LOG"

    if [[ -n "$HWKVM" || -n "$HWSEABIOS" ]]; then
      echo "40"
      echo "XXX"
      echo "Installing qemu-guest-agent..."
      echo "XXX"
      dnf -y install qemu-guest-agent >> "$DEBUG_LOG" 2>&1
    fi

    if [[ -n "$HWVMWARE" ]]; then
      echo "70"
      echo "XXX"
      echo "Installing open-vm-tools..."
      echo "XXX"
      dnf -y install open-vm-tools >> "$DEBUG_LOG" 2>&1
    fi

    echo "100"
    echo "XXX"
    echo "VM guest tools installation complete."
    echo "XXX"
    sleep 1
  ) > "$PIPE" &

  wait "$GAUGE_PID"
  rm -f "$PIPE"

  # Auto-dismiss final message after 4 seconds
  dialog --title "VM Guest Installation" --infobox \
    "Guest tools installed successfully." \
    8 60
  sleep 4
}

# ========= CHECK Firewall States and Services =========
config_fw_service() {
  local FIREWALLD_STATUS=""
  local NFTABLES_STATUS=""
  DEBUG_LOG="/tmp/firewall_config_debug.txt"
  echo "=== Firewall Configuration Log ===" > "$DEBUG_LOG"

  # Disable firewalld if running
  if systemctl is-active --quiet firewalld; then
    echo "[INFO] firewalld is running, disabling it..." >> "$DEBUG_LOG"
    systemctl stop firewalld >> "$DEBUG_LOG" 2>&1
    systemctl disable firewalld >> "$DEBUG_LOG" 2>&1
    FIREWALLD_STATUS="firewalld was running and has been disabled."
  else
    echo "[INFO] firewalld is not running." >> "$DEBUG_LOG"
    FIREWALLD_STATUS="firewalld was already stopped."
  fi

  # Enable nftables if not running
  if ! systemctl is-active --quiet nftables; then
    echo "[INFO] nftables is not running, enabling it..." >> "$DEBUG_LOG"
    systemctl start nftables >> "$DEBUG_LOG" 2>&1
    systemctl enable nftables >> "$DEBUG_LOG" 2>&1
    NFTABLES_STATUS="nftables was not running and has been started."
  else
    echo "[INFO] nftables is already running." >> "$DEBUG_LOG"
    NFTABLES_STATUS="nftables was already running."
  fi

  # Show final status to user with infobox
  dialog --title "Firewall Configuration" --infobox \
    "${FIREWALLD_STATUS}\n${NFTABLES_STATUS}" \
    8 60
  sleep 4
}
# ========= SET the inside interface with -inside =========
set_inside_interface() {
  DEBUG_LOG="/tmp/set_inside_interface_debug.txt"
  echo "=== Inside Interface Setup ===" > "$DEBUG_LOG"

  # Get active Ethernet connection
  active_connection=$(nmcli -t -f NAME,DEVICE,TYPE,STATE connection show --active \
    | grep ":802-3-ethernet:" \
    | grep ":activated")

  if [ -z "$active_connection" ]; then
    dialog --title "Error: No Ethernet Connection" --msgbox \
      "No active ethernet connections found.\n\nPlease connect to the internal network and try again." 7 60
    echo "[ERROR] No active ethernet connections found." >> "$DEBUG_LOG"
    exit 1
  fi

  # Parse connection info
  IFS=: read -r name device type state <<<"$active_connection"
  echo "[INFO] Active connection: $device ($name)" >> "$DEBUG_LOG"

  # Determine new name
  if [[ "$name" == *-inside ]]; then
    status_msg="The connection profile \"$name\" already ends with '-inside'. No change needed."
    echo "[INFO] Profile already ends with -inside" >> "$DEBUG_LOG"
  else
    new_profile_name="${name}-inside"
    echo "[INFO] Renaming connection $name -> $new_profile_name" >> "$DEBUG_LOG"
    nmcli connection modify "$name" connection.id "$new_profile_name" >> "$DEBUG_LOG" 2>&1
    nmcli connection reload >> "$DEBUG_LOG" 2>&1
    status_msg="Renamed connection \"$name\" to \"$new_profile_name\"."
  fi

  # Show final infobox message
  dialog --title "Inside Interface" --infobox \
    "$status_msg\n\nInterface detected: $device\n\n" 8 60
  sleep 4
}

# ========= SET VLANS IF we need to  =========
vlan_main(){
dialog --yesno "Would you like to configure VLANs on this system?" 7 50
response=$?

if [[ $response -eq 0 ]]; then
  vlan_configurator
else
  echo "Skipping VLAN configuration..."
  sleep 1
fi

}

vlan_configurator() {
  DEBUG_LOG="/tmp/vlan_debug.txt"
  echo "=== VLAN Setup Log ===" > "$DEBUG_LOG"

  dialog --title "VLAN Setup Notice" --msgbox \
"Considerations:

- Your current interface IP is untagged (native VLAN).
- DNS/DHCP will bind to all VLANs by default.
- Management apps (like Cockpit) bind only to untagged IP unless configured.
- Make sure your SSH session is in the untagged VLAN or you may lose access after changes." 20 70

  while true; do
    VLAN_INFO=$(nmcli -t -f NAME,DEVICE,TYPE connection show | grep ":vlan" | while IFS=: read -r name device type; do
      vlan_id="${device##*.}"
      ip=$(nmcli connection show "$name" | awk '/ipv4.addresses:/ {print $2}')
      echo "$device → $name (VLAN $vlan_id, ${ip:-No IP})"
    done)

    echo "$VLAN_INFO" > /tmp/vlan_map.txt
    dialog --title "Current VLAN Mappings" --textbox /tmp/vlan_map.txt 15 70

    dialog --menu "What would you like to do?" 12 50 4 \
      1 "Add a VLAN" \
      2 "Delete a VLAN" \
      3 "Exit" 2> /tmp/vlan_action

    case $(< /tmp/vlan_action) in
      1)
        IFS=$'\n' read -d '' -r -a interfaces < <(nmcli -t -f NAME,DEVICE connection show --active | grep -v '\.' | grep -v ':lo' && printf '\0'
)
        if [[ ${#interfaces[@]} -eq 0 ]]; then
          dialog --msgbox "No physical interfaces available." 5 40
          continue
        fi

        MENU_ITEMS=()
        for entry in "${interfaces[@]}"; do
          name="${entry%%:*}"
          dev="${entry##*:}"
          MENU_ITEMS+=("$dev" "$name")
        done

        dialog --menu "Select an interface for the VLAN:" 15 50 6 "${MENU_ITEMS[@]}" 2> /tmp/interface_choice
        selected_interface=$(< /tmp/interface_choice)

        while true; do
          dialog --inputbox "Enter VLAN ID (1-4094):" 8 40 2> /tmp/vlan_id
          vlan_id=$(< /tmp/vlan_id)

          existing_vlan_ifaces=$(nmcli -t -f DEVICE,TYPE connection show | grep ":vlan" | cut -d: -f1)
          for iface in $existing_vlan_ifaces; do
            if [[ "$iface" == "${selected_interface}.${vlan_id}" ]]; then
              dialog --msgbox "VLAN ID $vlan_id already exists on $selected_interface.\nPlease choose a different VLAN ID." 7 60
              continue 2
            fi
          done

          [[ "$vlan_id" =~ ^[0-9]+$ && "$vlan_id" -ge 1 && "$vlan_id" -le 4094 ]] && break
          dialog --msgbox "Invalid VLAN ID. Must be 1–4094." 5 40
        done

        while true; do
          dialog --inputbox "Enter IP address in CIDR format (e.g. 192.168.50.1/24):" 8 50 "192.168.10.1/24" 2> /tmp/vlan_ip
          vlan_ip=$(< /tmp/vlan_ip)

          if ! validate_cidr "$vlan_ip"; then
            dialog --msgbox "Invalid format. Use IP/CIDR format (e.g. 192.168.50.1/24)." 6 60
            continue
          fi

          if ! is_host_ip "$vlan_ip"; then
            dialog --msgbox "That IP is the network or broadcast address. Choose a valid host IP." 6 60
            continue
          fi

          host_ip="${vlan_ip%/*}"
          if ip -4 addr show | grep -q "$host_ip"; then
            dialog --msgbox "The IP address $host_ip is already assigned.\nPlease choose another." 6 60
            continue
          fi

          if ip -4 addr show | grep -q "$vlan_ip"; then
            dialog --msgbox "This exact CIDR is already in use.\nPlease use a different range." 6 60
            continue
          fi

          new_network=$(ipcalc -n "$vlan_ip" 2>/dev/null | awk -F= '/^NETWORK=/ {print $2}')
          if [[ -z "$new_network" ]]; then
            dialog --msgbox "Failed to calculate network. Please re-enter." 6 50
            continue
          fi

          subnet_in_use=0
          while IFS= read -r existing_ip; do
            existing_cidr=$(echo "$existing_ip" | awk '{print $2}')
            [[ -z "$existing_cidr" ]] && continue
            existing_network=$(ipcalc -n "$existing_cidr" 2>/dev/null | awk -F= '/^NETWORK=/ {print $2}')
            [[ "$existing_network" == "$new_network" ]] && subnet_in_use=1
          done < <(ip -4 addr show | grep -oP 'inet \K[\d./]+')

          if [[ "$subnet_in_use" -eq 1 ]]; then
            dialog --msgbox "The subnet $new_network is already in use.\nYou cannot assign it to multiple VLANs." 6 60
            continue
          fi

          break
        done

        while true; do
          dialog --inputbox "Enter a friendly name for the VLAN:" 8 50 2> /tmp/friendly_name
          friendly_name=$(< /tmp/friendly_name)

          if nmcli -t -f NAME connection show | grep -Fxq "$friendly_name"; then
            dialog --msgbox "The name \"$friendly_name\" already exists. Please choose another." 6 60
          else
            break
          fi
        done

        summary="Interface: $selected_interface
VLAN ID: $vlan_id
IP: $vlan_ip
Name: $friendly_name"

        dialog --yesno "Apply this configuration?\n\n$summary" 12 60 || continue

        vlan_conn="${selected_interface}.${vlan_id}"
        nmcli connection add type vlan con-name "$vlan_conn" dev "$selected_interface" id "$vlan_id" ip4 "$vlan_ip" >> "$DEBUG_LOG" 2>&1
        nmcli connection modify "$vlan_conn" connection.id "$friendly_name" >> "$DEBUG_LOG" 2>&1
        nmcli connection up "$friendly_name" >> "$DEBUG_LOG" 2>&1

        dialog --infobox "VLAN $vlan_id configured on $selected_interface as $friendly_name.\nContinuing..." 6 50
        sleep 4
        ;;

      2)
        VLAN_CONNS_RAW=($(nmcli -t -f NAME,DEVICE,TYPE connection show | grep ":vlan"))
        if [[ ${#VLAN_CONNS_RAW[@]} -eq 0 ]]; then
          dialog --msgbox "No VLAN connections found to delete." 5 50
          continue
        fi

        MENU_ITEMS=()
        for line in "${VLAN_CONNS_RAW[@]}"; do
          IFS=: read -r name device type <<< "$line"
          vlan_id="${device##*.}"
          ip=$(nmcli connection show "$name" | awk '/ipv4.addresses:/ {print $2}')
          display="${device} → $name (VLAN $vlan_id, ${ip:-No IP})"
          MENU_ITEMS+=("$name" "$display")
        done

        dialog --menu "Select a VLAN to delete:" 18 70 8 "${MENU_ITEMS[@]}" 2> /tmp/delete_choice
        selected_vlan=$(< /tmp/delete_choice)

        dialog --yesno "Are you sure you want to delete VLAN \"$selected_vlan\"?" 7 50 || continue

        nmcli connection delete "$selected_vlan" >> "$DEBUG_LOG" 2>&1
        dialog --infobox "VLAN \"$selected_vlan\" deleted successfully.\nContinuing..." 6 50
        sleep 3
        ;;

      3)
        break
        ;;
    esac
  done
}
# ========= Setup nftables SSH Allow rule inside interface with -inside =========
setup_nftables_inside() {
  # Locate interface ending in -inside
  interface=$(nmcli device status | awk '/-inside/ {print $1}')
  if [ -z "$interface" ]; then
    dialog --title "ERROR" --infobox "No interface ending in '-inside' found. Exiting..." 6 50
    sleep 4
    return 1
  fi

  friendly_name=$(nmcli -t -f DEVICE,NAME connection show --active | grep "^$interface:" | cut -d':' -f2)
  dialog --title "Inside Interface Found" --infobox "Inside interface: $interface\nConnection name: $friendly_name" 6 60
  sleep 4

  # Enable and start nftables
  systemctl enable nftables
  systemctl start nftables
  nft list ruleset > /etc/sysconfig/nftables.conf
  systemctl restart nftables

  # Ensure inet filter table/chain exist
  if ! nft list tables | grep -q 'inet filter'; then
    nft add table inet filter
  fi
  if ! nft list chain inet filter input &>/dev/null; then
    nft add chain inet filter input { type filter hook input priority 0 \; }
  fi

  # Find all related sub-interfaces
  all_interfaces=$(nmcli device status | awk -v intf="$interface" '$1 ~ intf {print $1}')

  for iface in $all_interfaces; do
    friendly_name=$(nmcli -t -f DEVICE,NAME connection show --active | grep "^$iface:" | cut -d':' -f2)

    if ! nft list chain inet filter input | grep -q "iifname \"$iface\" tcp dport 22 accept"; then
      nft add rule inet filter input iifname "$iface" tcp dport 22 accept
      dialog --title "Rule Added" --infobox "SSH allowed on $iface ($friendly_name)" 6 60
      sleep 4
    else
      dialog --title "Rule Exists" --infobox "SSH rule already present for $iface ($friendly_name)" 6 60
      sleep 4
    fi
  done

  dialog --title "Saving Ruleset" --infobox "Saving nftables rules to /etc/sysconfig/nftables.conf..." 5 60
  nft list ruleset > /etc/sysconfig/nftables.conf
  sleep 4

  dialog --title "nftables Reload" --infobox "Restarting nftables service to apply changes..." 5 50
  systemctl restart nftables
  sleep 4

  dialog --title "Done" --infobox "nftables SSH configuration completed successfully." 5 50
  sleep 4
}




# ========= MAIN =========
show_welcome_screen
network_interface_count
detect_active_interface
prompt_static_ip_if_dhcp
check_root_and_os
check_and_enable_selinux
check_internet_connectivity
validate_and_set_hostname
update_and_install_packages
vm_detection
config_fw_service
set_inside_interface
vlan_main
setup_nftables_inside
